local p = {}

function isEmpty(var)
	return var == nil or var == ""
end

Date = {
	-- _ = nil, -- save here the original date string, e.g. "31 май 2000"
	-- day = nil,
	-- month = nil,
	-- monthName = nil,
	-- year = nil,
	-- bc = nil,
}
function Date.currentDate()
	return os.date("*t")
end

function Date:isEmpty()
	return isEmpty(self._)
end
function Date:monthNameToNumber(monthName)
	local map = {
		["януари"] = 1,
		["февруари"] = 2,
		["март"]  = 3,
		["април"] = 4,
		["май"] = 5,
		["юни"] = 6,
		["юли"] = 7,
		["август"] = 8,
		["септември"] = 9,
		["октомври"] = 10,
		["ноември"] = 11,
		["декември"] = 12
	}
	return map[monthName] or nil
end
function Date:set(year, monthName, day)
	self.year = year
	self.monthName = monthName
	self.month = self:monthNameToNumber(monthName)
	self.day = day
	return self
end

function Date:fromString(dateString)
	d = { _ = dateString }
	setmetatable(d, self)
	self.__index = self
	if isEmpty(dateString) then
		return d
	end
	if string.match(dateString, 'BC$') then
		d.bc = true
	end
	local day, monthName, year = mw.ustring.match(dateString, "^(%d+) (%a+) (%d+)")
	if day and monthName and year then
		return d:set(year, monthName, day)
	end
	monthName, year = mw.ustring.match(dateString, "^(%a+) (%d+)")
	if monthName and year then
		return d:set(year, monthName)
	end
	century = mw.ustring.match(dateString, "^(%d+)\. century")
	if century then
		d.century = century
		return d
	end
	year = mw.ustring.match(dateString, "^(%d+)")
	if year then
		return d:set(year)
	end

	return d
end


function age(dateOfBirth, dateOfDeath)
	if not dateOfBirth.year then
		return nil
	end
	if isEmpty(dateOfDeath) or dateOfDeath:isEmpty() then
		dateOfDeath = Date.currentDate()
	end
	local startDate = dateForCalc(dateOfBirth)
	local endDate = dateForCalc(dateOfDeath)
	if dateOfBirth.bc and not dateOfDeath.bc then
		-- reverse the sign and subtract one year
		startDate = startDate * -1 + 10000
	end
	local age = math.abs(math.floor((endDate - startDate) / 10000))
	if age > 125 then -- put a max age
		return nil
	end
	return age
end

function dateForCalc(date)
	return string.format("%d%02d%02d", date.year or 0, date.month or 0, date.day or 0)
end

function birthCategories(date)
	local cats = {}
	if date.century then
		table.insert(cats, "Родени през " ..  date.century .. " век" .. bcSuffix(date.bc))
	end
	if date.year then
		table.insert(cats, "Родени през " ..  date.year .. " година" .. bcSuffix(date.bc))
	end
	if date.day and date.monthName then
		table.insert(cats, "Родени на " ..  date.day .. " " .. date.monthName)
	end
	return cats
end

function deathCategories(date)
	local cats = {}
	if date.century then
		table.insert(cats, "Починали през " ..  date.century .. " век" .. bcSuffix(date.bc))
	end
	if date.year then
		table.insert(cats, "Починали през " ..  date.year .. " година" .. bcSuffix(date.bc))
	end
	if date.day and date.monthName then
		table.insert(cats, "Починали на " ..  date.day .. " " .. date.monthName)
	end
	return cats
end

function prepareBirthDateVars(dateOfBirthString, dateOfDeathString)
	if isEmpty(dateOfBirthString) then
		return nil
	end
	local vars = {}
	vars.date = Date:fromString(dateOfBirthString)
	if isEmpty(dateOfDeathString) then
		vars.age = age(vars.date)
	end
	vars.cats = birthCategories(vars.date)
	return vars
end

function prepareDeathDateVars(dateOfBirthString, dateOfDeathString)
	if isEmpty(dateOfDeathString) then
		return nil
	end
	local vars = {}
	vars.date = Date:fromString(dateOfDeathString)
	if not isEmpty(dateOfBirthString) then
		vars.age = age(Date:fromString(dateOfBirthString), vars.date)
	end
	vars.cats = deathCategories(vars.date)
	return vars
end

function wikifyDate(date)
	if date.century then
		return "[[" .. date.century .. " век" .. bcSuffix(date.bc) .. "]]"
	end
	local output = ""
	if date.day and date.monthName then
		output = output .. "[[" .. date.day .. " " .. date.monthName .. "]] "
	end
	if date.year then
		output = output .. "[[" .. date.year .. (date.bc and " г. пр.н.е.]]" or "]] г.")
	end
	return output
end

function bcSuffix(isBc)
	if isBc then return " пр.н.е." else return "" end
end

function formatAgeSuffix(age)
	return '<span class="noprint"> <small>('.. age .. ' г.)</small></span>'
end

function formatDate(vars)
	if vars == nil then
		return ""
	end
	local output = wikifyDate(vars.date)
	if vars.age then
		output = output .. formatAgeSuffix(vars.age)
	end
	output = '<span class="oneline">' .. output .. '</span>'
	for k, category in pairs(vars.cats) do
		output = output .. '[[Category:' .. category .. ']]'
	end
	return output
end

function p.birth_date(frame)
	return formatDate(prepareBirthDateVars(frame.args[1], frame.args[2]))
end

function p.death_date(frame)
	return formatDate(prepareDeathDateVars(frame.args[1], frame.args[2]))
end

return p