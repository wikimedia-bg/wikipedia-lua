--[[
Този модул има за цел да замени функционалността на {{Coord}} и свързаните 
шаблони.  Той предоставя няколко метода, включително:

{{#Invoke:Координати | coord }} : Функция, която форматира и показва координати.

{{#Invoke:Координати | dec2dms }} : Функция, която превръща градуси записани 
като десетична стойност във формат DMS.

{{#Invoke:Координати | dms2dec }} : Превръща DMS в десетична стойност.

]]

math_mod = require( "Модул:Math" );
globalFrame = nil

coordinates = {};

--[[ Helper function, replacement for {{coord/display/title}} ]]
function displaytitle (s, notes)
    local l = "[[Географска координтна система|Координати]]: " .. s
    local co = '<span id="coordinates">' .. l .. notes .. '</span>';
    return '<span style="font-size: small;">' .. co .. '</span>';
end

--[[ функция Helper, заместител на {{coord/display/inline}} ]]
function displayinline (s, notes)
    return s .. notes    
end

--[[ Helper function, used in detecting DMS formatting ]]
local dmsTest = function(first, second)
    local concatenated = first:upper() .. second:upper();
    
    if concatenated == "NE" or concatenated == "NW" or concatenated == "SE" or concatenated == "SW" or
        concatenated == "EN" or concatenated == "WN" or concatenated == "ES" or concatenated == "WS" then
        return true;
    end
    return false;
end

--[[
parseDec

Transforms decimal format latitude and longitude into the a
structure to be used in displaying coordinates
]]
function parseDec( lat, long, format )
    local coordinateSpec = {}
    local errors = {}
    
    if long == "" or long == nil then
        return nil, {{"parseDec", "Missing longitude"}}
    end
    
    errors = validate( lat, nil, nil, long, nil, nil, 'parseDec', false );    
    coordinateSpec["dec-lat"]  = lat;
    coordinateSpec["dec-long"] = long;

    local mode = coordinates.determineMode( lat, long );
    coordinateSpec["dms-lat"]  = convert_dec2dms( lat, "N", "S", mode)  -- {{coord/dec2dms|{{{1}}}|N|S|{{coord/prec dec|{{{1}}}|{{{2}}}}}}}
    coordinateSpec["dms-long"] = convert_dec2dms( long, "E", "W", mode)  -- {{coord/dec2dms|{{{2}}}|E|W|{{coord/prec dec|{{{1}}}|{{{2}}}}}}}    
    
    if format ~= "" then
        coordinateSpec.default = format
    else
        coordinateSpec.default = "dec"
    end

    return coordinateSpec, errors
end

--[[ Helper function, handle optional args. ]]
function optionalArg(arg, suplement)
    if arg ~= nil and arg ~= "" then
        return arg .. suplement
    end
    return ""
end

--[[
parseDMS

Transforms degrees, minutes, seconds format latitude and longitude 
into the a structure to be used in displaying coordinates
]]
function parseDMS( lat_d, lat_m, lat_s, lat_f, long_d, long_m, long_s, long_f, format )
    local coordinateSpec = {}
    local errors = {}
    
    lat_f = lat_f:upper();
    long_f = long_f:upper();
    
    -- Check if specified backward
    if lat_f == 'E' or lat_f == 'W' then
        local t_d, t_m, t_s, t_f;
        t_d = lat_d;
        t_m = lat_m;
        t_s = lat_s;
        t_f = lat_f;
        lat_d = long_d;
        lat_m = long_m;
        lat_s = long_s;
        lat_f = long_f;
        long_d = t_d;
        long_m = t_m;
        long_s = t_s;
        long_f = t_f;
    end    
    
    errors = validate( lat_d, lat_m, lat_s, long_d, long_m, long_s, 'parseDMS', true );
    if long_d == nil or long_d == "" then
        table.insert(errors, {"parseDMS", "Missing longitude" })
    end
    
    if lat_m == nil and lat_s == nil and long_m == nil and long_s == nil and #errors == 0 then 
        if math_mod._precision( lat_d ) > 0 or math_mod._precision( long_d ) > 0 then
            if lat_f:upper() == 'S' then 
                lat_d = '-' .. lat_d;
            end
            if long_f:upper() == 'W' then 
                long_d = '-' .. long_d;
            end     
            
            return parseDec( lat_d, long_d, format );
        end        
    end   
    
    coordinateSpec["dms-lat"]  = lat_d.."°"..optionalArg(lat_m,"′") .. optionalArg(lat_s,"″") .. lat_f
    coordinateSpec["dms-long"] = long_d.."°"..optionalArg(long_m,"′") .. optionalArg(long_s,"″") .. long_f
    coordinateSpec["dec-lat"]  = convert_dms2dec(lat_f, lat_d, lat_m, lat_s) -- {{coord/dms2dec|{{{4}}}|{{{1}}}|0{{{2}}}|0{{{3}}}}}
    coordinateSpec["dec-long"] = convert_dms2dec(long_f, long_d, long_m, long_s) -- {{coord/dms2dec|{{{8}}}|{{{5}}}|0{{{6}}}|0{{{7}}}}}

    if format ~= "" then
        coordinateSpec.default = format
    else
        coordinateSpec.default = "dms"
    end   

    return coordinateSpec, errors
end

--[[
specPrinter

Output formatter.  Takes the structure generated by either parseDec
or parseDMS and formats it for inclusion on Wikipedia.
]]
function specPrinter(args, coordinateSpec)
    local uriComponents = coordinateSpec["param"]
    if uriComponents == "" then
        -- RETURN error, should never be empty or nil
        return "ERROR param was empty"
    end
    if args["name"] ~= "" and args["name"] ~= nil then
        uriComponents = uriComponents .. "&title=" .. mw.uri.encode(coordinateSpec["name"])
    end
    
    local geodmshtml = '<span class="geo-dms" title="Maps, aerial photos, and other data for this location">'
             .. '<span class="latitude">' .. coordinateSpec["dms-lat"] .. '</span> '
             .. '<span class="longitude">' ..coordinateSpec["dms-long"] .. '</span>'
             .. '</span>'

    local lat = tonumber( coordinateSpec["dec-lat"] ) or 0
    if lat < 0 then
        -- FIXME this breaks the pre-existing precision
        geodeclat = coordinateSpec["dec-lat"]:sub(2) .. "°S"
    else
        geodeclat = (coordinateSpec["dec-lat"] or 0) .. "°N"
    end

    local long = tonumber( coordinateSpec["dec-long"] ) or 0
    if long < 0 then
        -- FIXME does not handle unicode minus
        geodeclong = coordinateSpec["dec-long"]:sub(2) .. "°W"
    else
        geodeclong = (coordinateSpec["dec-long"] or 0) .. "°E"
    end
    
    local geodechtml = '<span class="geo-dec" title="Maps, aerial photos, and other data for this location">'
             .. geodeclat .. ' '
             .. geodeclong
             .. '</span>'

    local geonumhtml = '<span class="geo">'
             .. coordinateSpec["dec-lat"] .. '; '
             .. coordinateSpec["dec-long"]
             .. '</span>'

    local inner;
    inner = '<span class="' .. displayDefault(coordinateSpec["default"], "dms" ) .. '">' .. geodmshtml .. '</span>'
                .. '<span class="geo-multi-punct">&#xfeff; / &#xfeff;</span>'
                .. '<span class="' .. displayDefault(coordinateSpec["default"], "dec" ) .. '">';

    if args["name"] == "" or args["name"] == nil then
        inner = inner .. geodechtml 
                .. '<span style="display:none">&#xfeff; / ' .. geonumhtml .. '</span></span>'
    else
        inner = inner .. '<span class="vcard">' .. geodechtml 
                .. '<span style="display:none">&#xfeff; / ' .. geonumhtml .. '</span>'
                .. '<span style="display:none">&#xfeff; (<span class="fn org">'
                .. args["name"] .. '</span>)</span></span></span>'
    end

    return '<span class="plainlinks nourlexpansion">' .. globalFrame:preprocess(
        '[http://toolserver.org/~geohack/geohack.php?pagename={{FULLPAGENAMEE}}&params=' ..
        uriComponents .. ' ' .. inner .. ']') .. '</span>'
end

--[[
Formats any error messages generated for display
]]
function errorPrinter(errors)
    local result = ""
    for i,v in ipairs(errors) do
        local errorHTML = '<strong class="error">Coordinates: ' .. v[2] .. '</strong>'
        result = result .. errorHTML .. "<br />"
    end
    return result
end

--[[
Determine the required CSS class to display coordinates

Usually geo-nondefault is hidden by CSS, unless a user has overridden this for himself
default is the mode as specificied by the user when calling the {{coord}} template
mode is the display mode (dec or dms) that we will need to determine the css class for 
]]
function displayDefault(default, mode)
    if default == "" then
        default = "dec"
    end
    
    if default == mode then
        return "geo-default"
    else
        return "geo-nondefault"
    end
end

--[[ 
Check the input arguments for coord to determine the kind of data being provided
and then make the necessary processing.
]]
function formatTest(args)
    local result, errors;
    local primary = false;
    
    if args[1] == "" then
        -- no lat logic
        return errorPrinter( {{"formatTest", "Missing latitude"}} )
    elseif args[4] == "" and args[5] == "" and args[6] == "" then
        -- dec logic
        result, errors = parseDec( args[1], args[2], args['format'] )
        if result == nil then
            return errorPrinter( errors );
        end              
        result.param    = table.concat( {args[1], "_N_", args[2], "_E_", args[3] } );
    elseif dmsTest(args[4], args[8]) then
        -- dms logic
        result, errors = parseDMS( args[1], args[2], args[3], args[4], 
            args[5], args[6], args[7], args[8], args['format'] )
        result.param = table.concat( { args[1], args[2], args[3], args[4], args[5],
            args[6], args[7], args[8], args[9] } , '_' );
        if args[10] ~= '' then
            table.insert( errors, { 'formatTest', 'Extra unexpected parameters' } );
        end        
    elseif dmsTest(args[3], args[6]) then
        -- dm logic
        result, errors = parseDMS( args[1], args[2], nil, args[3], 
            args[4], args[5], nil, args[6], args['format'] )
        result.param = table.concat( { args[1], args[2], args[3], args[4], args[5],
            args[6], args[7] } , '_' );
        if args[8] ~= '' then
            table.insert( errors, { 'formatTest', 'Extra unexpected parameters' } );
        end        
    elseif dmsTest(args[2], args[4]) then
        -- d logic
        result, errors = parseDMS( args[1], nil, nil, args[2], 
            args[3], nil, nil, args[4], args['format'] )
        result.param = table.concat( { args[1], args[2], args[3], args[4], args[5] } , '_' );
        if args[6] ~= '' then
            table.insert( errors, { 'formatTest', 'Extra unexpected parameters' } );
        end        
    else
        -- Error
        return errorPrinter( {{"formatTest", "Unknown argument format"}} )
    end
    result.name     = args["name"]
    
    local extra_param = {'dim', 'globe', 'scale', 'region', 'source', 'type'}
    for _, v in ipairs( extra_param ) do
        if (args[v] or '') ~= '' then 
            table.insert( errors, {'formatTest', 'Parameter: "' .. v .. '=" should be "' .. v .. ':"' } );
        end
    end
    
    if #errors == 0 then
        return specPrinter( args, result )    
    else
        return specPrinter( args, result ) .. " " .. errorPrinter(errors) .. '[[Category:Pages with malformed coordinate tags]]'; 
    end    
end

--[[ 
Helper function, convert decimal latitude or longitude to 
degrees, minutes, and seconds format based on the specified precision.  
]]
function convert_dec2dms(coordinate, firstPostfix, secondPostfix, precision)
    local coord = tonumber(coordinate) or 0
    local postfix
    if coord >= 0 then
        postfix = firstPostfix
    else
        postfix = secondPostfix
    end

    precision = precision:lower();
    if precision == "dms" then
        return convert_dec2dms_dms( math.abs( coord ) ) .. postfix;
    elseif precision == "dm" then
        return convert_dec2dms_dm( math.abs( coord ) ) .. postfix;
    elseif precision == "d" then
        return convert_dec2dms_d( math.abs( coord ) ) .. postfix;
    end
end

--[[ Helper function, convert decimal to degrees ]]
function convert_dec2dms_d(coordinate)
    local d = math_mod._round( coordinate, 0 ) .. "°"
    return d .. ""
end

--[[ Helper function, convert decimal to degrees and minutes ]]
function convert_dec2dms_dm(coordinate)    
    coordinate = math_mod._round( coordinate * 60, 0 );
    local m = coordinate % 60;
    coordinate = math.floor( (coordinate - m) / 60 );
    local d = coordinate % 360 .."°"
    
    return d .. string.format( "%02d′", m )
end

--[[ Helper function, convert decimal to degrees, minutes, and seconds ]]
function convert_dec2dms_dms(coordinate)
    coordinate = math_mod._round( coordinate * 60 * 60, 0 );
    local s = coordinate % 60
    coordinate = math.floor( (coordinate - s) / 60 );
    local m = coordinate % 60
    coordinate = math.floor( (coordinate - m) / 60 );
    local d = coordinate % 360 .."°"

    return d .. string.format( "%02d′", m ) .. string.format( "%02d″", s )
end

--[[
Convert DMS format into a N or E decimal coordinate
]]
function convert_dms2dec(direction, degrees_str, minutes_str, seconds_str)
    local degrees = tonumber(degrees_str) or 0
    local minutes = tonumber(minutes_str) or 0
    local seconds = tonumber(seconds_str) or 0
    
    local factor
    if direction == "N" or direction == "E" then
        factor = 1
    else
        factor = -1
    end
    
    local precision = 0
    if seconds_str ~= nil and seconds_str ~= '' then
        precision = 5 + math.max( math_mod._precision(seconds_str), 0 );
    elseif minutes_str ~= nil and minutes_str ~= '' then
        precision = 3 + math.max( math_mod._precision(minutes_str), 0 );
    else
        precision = math.max( math_mod._precision(degrees_str), 0 );
    end
    
    local decimal = factor * (degrees+(minutes+seconds/60)/60) 
    return string.format( "%." .. precision .. "f", decimal ) -- not tonumber since this whole thing is string based.
end

--[[ 
Checks input values to for out of range errors.
]]
function validate( lat_d, lat_m, lat_s, long_d, long_m, long_s, source, strong )
    local errors = {};
    lat_d = tonumber( lat_d ) or 0;
    lat_m = tonumber( lat_m ) or 0;
    lat_s = tonumber( lat_s ) or 0;
    long_d = tonumber( long_d ) or 0;
    long_m = tonumber( long_m ) or 0;
    long_s = tonumber( long_s ) or 0;

    if strong then
        if lat_d < 0 then
            table.insert(errors, {source, "latitude degrees < 0 with hemisphere flag"})
        end
        if long_d < 0 then
            table.insert(errors, {source, "longitude degrees < 0 with hemisphere flag"})
        end
        --[[ 
        #coordinates is inconsistent about whether this is an error.  If globe: is
        specified, it won't error on this condition, but otherwise it will.
        
        For not simply disable this check.
        
        if long_d > 180 then
            table.insert(errors, {source, "longitude degrees > 180 with hemisphere flag"})
        end
        ]]
    end    
        
    if lat_d > 90 then
        table.insert(errors, {source, "latitude degrees > 90"})
    end
    if lat_d < -90 then
        table.insert(errors, {source, "latitude degrees < -90"})
    end
    if lat_m >= 60 then
        table.insert(errors, {source, "latitude minutes >= 60"})
    end
    if lat_m < 0 then
        table.insert(errors, {source, "latitude minutes < 0"})
    end
    if lat_s >= 60 then
        table.insert(errors, {source, "latitude seconds >= 60"})
    end
    if lat_s < 0 then
        table.insert(errors, {source, "latitude seconds < 0"})
    end
    if long_d >= 360 then
        table.insert(errors, {source, "longitude degrees >= 360"})
    end
    if long_d <= -360 then
        table.insert(errors, {source, "longitude degrees <= -360"})
    end
    if long_m >= 60 then
        table.insert(errors, {source, "longitude minutes >= 60"})
    end
    if long_m < 0 then
        table.insert(errors, {source, "longitude minutes < 0"})
    end
    if long_s >= 60 then
        table.insert(errors, {source, "longitude seconds >= 60"})
    end
    if long_s < 0 then
        table.insert(errors, {source, "longitude seconds < 0"})
    end
    
    return errors;
end

--[[
dec2dms

Wrapper to allow templates to call dec2dms directly.

Usage:
    {{ Invoke:Coordinates | dec2dms | decimal_coordinate | positive_suffix | 
        negative_suffix | precision }}
    
decimal_coordinate is converted to DMS format.  If positive, the positive_suffix
is appended (typical N or E), if negative, the negative suffix is appended.  The
specified precision is one of 'D', 'DM', or 'DMS' to specify the level of detail
to use.
]]
function coordinates.dec2dms(frame)
    globalFrame = frame
    local coordinate = frame.args[1]
    local firstPostfix = frame.args[2]
    local secondPostfix = frame.args[3]
    local precision = frame.args[4]

    return convert_dec2dms(coordinate, firstPostfix, secondPostfix, precision)
end

--[[
Helper function to determine whether to use D, DM, or DMS
format depending on the precision of the decimal input.
]]
function coordinates.determineMode( value1, value2 )
    local precision = math.max( math_mod._precision( value1 ), math_mod._precision( value2 ) );
    if precision <= 0 then
        return 'd'
    elseif precision <= 2 then
        return 'dm';
    else
        return 'dms';
    end
end        

--[[
dms2dec

Wrapper to allow templates to call dms2dec directly.

Usage:
    {{ Invoke:Coordinates | dms2dec | direction_flag | degrees | 
        minutes | seconds }}
    
Converts DMS values specified as degrees, minutes, seconds too decimal format.
direction_flag is one of N, S, E, W, and determines whether the output is 
positive (i.e. N and E) or negative (i.e. S and W).
]]
function coordinates.dms2dec(frame)
    globalFrame = frame
    local direction = frame.args[1]
    local degrees = frame.args[2]
    local minutes = frame.args[3]
    local seconds = frame.args[4]

    return convert_dms2dec(direction, degrees, minutes, seconds)
end

--[[
coord

Main entry point for Lua function to replace {{coord}}

Usage:
    {{ Invoke:Coordinates | coord }}
    {{ Invoke:Coordinates | coord | lat | long }}
    {{ Invoke:Coordinates | coord | lat | lat_flag | long | long_flag }}
    ...
    
    Refer to {{coord}} documentation page for many additional parameters and 
    configuration options.
    
Note: This function provides the visual display elements of {{coord}}.  In
order to load coordinates into the database, the {{#coordinates:}} parser 
function must also be called, this is done automatically in the Lua
version of {{coord}}.
]]
function coordinates.coord(frame)
    globalFrame = frame
    local args = frame.args
    if args[1] == nil then
        local pFrame = frame:getParent();
        args = pFrame.args;
        for k,v in pairs( frame.args ) do
            args[k] = v;
        end
    end
    
    for i=1,10 do 
        if args[i] == nil then 
            args[i] = ""
        else
            args[i] = args[i]:match( '^%s*(.-)%s*$' );  --remove whitespace
        end        
    end
    args['format'] = args['format'] or '';
    
    local contents = formatTest(args)
    local Notes = args.notes or ""
    local Display = string.lower(args.display or "inline")
    if Display == '' then
        Display = 'inline';
    end
    
    local text = ''
    if string.find( Display, 'inline' ) ~= nil or Display == 't' or 
            Display == 'it' or Display == 'ti' then
        text = displayinline(contents, Notes)
    end
    if string.find( Display, 'title' ) ~= nil or Display == 'i' or 
            Display == 'it' or Display == 'ti' then
        text = text .. displaytitle(contents, Notes)
    end
    return text
end

return coordinates